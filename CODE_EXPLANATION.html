<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Solving Agent - Complete Code Explanation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 40px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        h3 {
            color: #555;
            margin-top: 25px;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
        }
        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.4;
        }
        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .tip {
            background-color: #d1ecf1;
            border-left: 4px solid #0c5460;
            padding: 15px;
            margin: 20px 0;
        }
        .warning {
            background-color: #f8d7da;
            border-left: 4px solid #721c24;
            padding: 15px;
            margin: 20px 0;
        }
        .info {
            background-color: #d4edda;
            border-left: 4px solid #155724;
            padding: 15px;
            margin: 20px 0;
        }
        ul, ol {
            margin-left: 20px;
        }
        li {
            margin: 8px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        @media print {
            body {
                background-color: white;
            }
            .container {
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† Maze Solving Agent - Complete Code Explanation</h1>
        <h2>A Beginner-Friendly Guide to Understanding the Code</h2>

        <h2>üìö Table of Contents</h2>
        <ol>
            <li><a href="#what-is-this-project">What is This Project?</a></li>
            <li><a href="#project-structure">Project Structure</a></li>
            <li><a href="#understanding-python-basics">Understanding Python Basics Used</a></li>
            <li><a href="#file-by-file">File-by-File Explanation</a></li>
            <li><a href="#how-everything-works">How Everything Works Together</a></li>
            <li><a href="#step-by-step">Step-by-Step Code Walkthrough</a></li>
        </ol>

        <h2 id="what-is-this-project">üéØ What is This Project?</h2>
        <p>This project creates a <strong>maze-solving robot</strong> that uses artificial intelligence to find the shortest path from a starting point to a goal. Think of it like a robot in a maze trying to find the exit!</p>

        <h3>Key Concepts:</h3>
        <ul>
            <li><strong>Maze</strong>: A grid with walls (obstacles) and open paths</li>
            <li><strong>Agent</strong>: The robot that moves through the maze</li>
            <li><strong>A* Algorithm</strong>: A smart search algorithm that finds the best path</li>
            <li><strong>Visualization</strong>: We use Pygame to see the robot moving in real-time</li>
        </ul>

        <h2 id="project-structure">üìÅ Project Structure</h2>
        <pre><code>maze-solving-agent/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.py      # Main program with graphics and controls
‚îÇ   ‚îú‚îÄ‚îÄ maze.py      # Maze class - handles maze data
‚îÇ   ‚îî‚îÄ‚îÄ astar.py     # A* algorithm - finds the path
‚îú‚îÄ‚îÄ mazes/
‚îÇ   ‚îú‚îÄ‚îÄ example_maze.txt
‚îÇ   ‚îú‚îÄ‚îÄ small_maze.txt
‚îÇ   ‚îî‚îÄ‚îÄ ... (more maze files)
‚îî‚îÄ‚îÄ requirements.txt</code></pre>

        <h2 id="understanding-python-basics">üêç Understanding Python Basics Used</h2>
        <p>Before diving into the code, let's understand some Python concepts:</p>

        <h3>1. Variables</h3>
        <pre><code>CELL_SIZE = 30  # A constant value
maze = Maze.from_file(file)  # A variable that stores a maze object</code></pre>

        <h3>2. Lists and Tuples</h3>
        <pre><code># List: can change
colors = [255, 255, 255]

# Tuple: cannot change (immutable)
position = (5, 10)  # row 5, column 10</code></pre>

        <h3>3. Functions</h3>
        <pre><code>def function_name(parameter):
    # Do something
    return result</code></pre>

        <h3>4. Classes</h3>
        <pre><code>class Maze:
    def __init__(self, grid):
        self.grid = grid  # 'self' refers to the object itself</code></pre>

        <h3>5. Loops</h3>
        <pre><code># For loop - repeat for each item
for row in range(10):
    print(row)

# While loop - repeat while condition is true
while running:
    # Do something</code></pre>

        <h2 id="file-by-file">üìÑ File-by-File Explanation</h2>

        <h3>File 1: <code>maze.py</code> - The Maze Class</h3>
        <p>This file defines what a maze is and what it can do.</p>

        <h4>What is a Class?</h4>
        <p>A class is like a blueprint. Think of it as a cookie cutter - you can make many cookies (objects) from one cutter (class).</p>

        <h4>The Maze Class Structure:</h4>
        <pre><code>class Maze:
    def __init__(self, grid, start=None, goal=None):
        self.grid = grid
        self.height = len(grid)
        self.width = len(grid[0]) if self.height > 0 else 0
        self.start = start
        self.goal = goal</code></pre>

        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>__init__</code> is a special function called when you create a new maze</li>
            <li><code>self.grid</code>: The maze layout (0 = open path, 1 = wall)</li>
            <li><code>self.height</code>: Number of rows</li>
            <li><code>self.width</code>: Number of columns</li>
            <li><code>self.start</code>: Starting position (row, column)</li>
            <li><code>self.goal</code>: Goal position (row, column)</li>
        </ul>

        <h4>Key Methods Explained:</h4>

        <h5>1. <code>from_file(cls, path)</code> - Loading a Maze from File</h5>
        <pre><code>@classmethod
def from_file(cls, path):
    lines = []
    with open(path, 'r', encoding='utf-8') as f:
        for ln in f:
            if ln.strip() == '':
                continue
            lines.append(ln.rstrip('\n'))</code></pre>

        <p><strong>What it does:</strong></p>
        <ul>
            <li>Opens a text file</li>
            <li>Reads each line</li>
            <li>Converts characters to numbers:
                <ul>
                    <li><code>#</code> or <code>1</code> ‚Üí wall (1)</li>
                    <li><code>.</code> or space ‚Üí open path (0)</li>
                    <li><code>S</code> ‚Üí start position</li>
                    <li><code>G</code> ‚Üí goal position</li>
                </ul>
            </li>
        </ul>

        <h5>2. <code>neighbors(self, pos)</code> - Finding Adjacent Cells</h5>
        <pre><code>def neighbors(self, pos):
    r, c = pos
    for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):
        nr, nc = r + dr, c + dc
        if self.in_bounds((nr, nc)) and self.passable((nr, nc)):
            yield (nr, nc)</code></pre>

        <p><strong>What it does:</strong></p>
        <ul>
            <li>Takes a position (row, column)</li>
            <li>Checks 4 directions: up, down, left, right</li>
            <li>Returns only valid, passable neighbors</li>
            <li><code>yield</code> is like <code>return</code>, but for generators (more efficient)</li>
        </ul>

        <h3>File 2: <code>astar.py</code> - The A* Search Algorithm</h3>
        <p>This is the "brain" that finds the best path!</p>

        <h4>What is A* Algorithm?</h4>
        <p>A* (A-star) is a pathfinding algorithm that:</p>
        <ol>
            <li>Explores possible paths</li>
            <li>Uses a "heuristic" (educated guess) to prioritize promising paths</li>
            <li>Always finds the shortest path if one exists</li>
        </ol>

        <h4>The Algorithm Step-by-Step:</h4>
        <pre><code>def astar_search(maze, heuristic=manhattan):
    start, goal = maze.start, maze.goal
    frontier = [(0, start)]  # Priority queue: (priority, position)
    came_from = {start: None}  # Track where we came from
    gscore = {start: 0}  # Cost to reach each position
    explored = set()  # Positions we've already checked</code></pre>

        <p><strong>Key Variables:</strong></p>
        <ul>
            <li><code>frontier</code>: Positions to explore next (like a to-do list)</li>
            <li><code>came_from</code>: Remembers the path (like breadcrumbs)</li>
            <li><code>gscore</code>: Actual cost to reach each position</li>
            <li><code>explored</code>: Positions we've already visited</li>
        </ul>

        <h4>The Main Loop:</h4>
        <pre><code>while frontier:
    _, current = heapq.heappop(frontier)  # Get best position
    
    if current == goal:  # Found the goal!
        # Reconstruct path
        path = []
        while current is not None:
            path.append(current)
            current = came_from[current]
        path.reverse()
        return path
    
    explored.add(current)
    
    # Check neighbors
    for neighbor in maze.neighbors(current):
        new_cost = gscore[current] + 1
        if neighbor not in gscore or new_cost < gscore[neighbor]:
            gscore[neighbor] = new_cost
            fscore = new_cost + heuristic(neighbor, goal)
            heapq.heappush(frontier, (fscore, neighbor))
            came_from[neighbor] = current</code></pre>

        <h3>File 3: <code>main.py</code> - The Main Program</h3>
        <p>This file handles:</p>
        <ul>
            <li>Graphics (drawing the maze)</li>
            <li>User input (keyboard and mouse)</li>
            <li>Animation (showing the robot move)</li>
        </ul>

        <h4>Color Constants:</h4>
        <pre><code>WHITE = (255, 255, 255)  # RGB color values
WALL = (0, 255, 0)       # Green for walls
START = (0, 200, 0)      # Darker green for start
GOAL = (255, 0, 0)       # Red for goal
PATH = (255, 215, 0)     # Gold for path
EXPLORED = (100, 149, 237)  # Blue for explored cells
AGENT = (255, 0, 255)    # Magenta for the robot</code></pre>

        <p><strong>RGB Colors:</strong> Each color is represented by three numbers (0-255):</p>
        <ul>
            <li>Red, Green, Blue</li>
            <li>(255, 0, 0) = Pure Red</li>
            <li>(0, 255, 0) = Pure Green</li>
            <li>(0, 0, 255) = Pure Blue</li>
        </ul>

        <h2 id="how-everything-works">üîÑ How Everything Works Together</h2>

        <h3>The Flow:</h3>
        <ol>
            <li><strong>Program Starts</strong> ‚Üí <code>main()</code> function runs</li>
            <li><strong>Load Maze</strong> ‚Üí Reads from text file</li>
            <li><strong>Initialize Graphics</strong> ‚Üí Creates Pygame window</li>
            <li><strong>Start A* Search</strong> ‚Üí Creates generator</li>
            <li><strong>Game Loop Begins:</strong>
                <ul>
                    <li>Check for user input</li>
                    <li>Get next step from A* algorithm</li>
                    <li>Draw everything on screen</li>
                    <li>Repeat</li>
                </ul>
            </li>
            <li><strong>User Interacts:</strong>
                <ul>
                    <li>Presses keys or clicks mouse</li>
                    <li>Maze changes</li>
                    <li>Search restarts</li>
                </ul>
            </li>
            <li><strong>Path Found:</strong>
                <ul>
                    <li>A* returns the path</li>
                    <li>Robot animates along the path</li>
                    <li>Done!</li>
                </ul>
            </li>
        </ol>

        <h3>Data Flow:</h3>
        <pre><code>Maze File (text)
    ‚Üì
Maze Class (converts to grid)
    ‚Üì
A* Algorithm (finds path)
    ‚Üì
Main Program (displays on screen)
    ‚Üì
User sees animation</code></pre>

        <h2 id="step-by-step">üìñ Step-by-Step Code Walkthrough</h2>

        <h3>Example: What happens when you press 'A'?</h3>
        <ol>
            <li><strong>User presses 'A' key</strong>
                <pre><code>elif event.key == pygame.K_a:</code></pre>
            </li>
            <li><strong>Add random obstacles</strong>
                <pre><code>added = augment_obstacles(maze, 10)</code></pre>
                <ul>
                    <li>Calls <code>maze.add_random_obstacles(10)</code></li>
                    <li>Randomly picks 10 empty cells</li>
                    <li>Changes them to walls (1)</li>
                </ul>
            </li>
            <li><strong>Restart search</strong>
                <pre><code>restart_search()</code></pre>
                <ul>
                    <li>Creates new A* generator</li>
                    <li>Resets agent position</li>
                    <li>Starts fresh search</li>
                </ul>
            </li>
            <li><strong>Screen updates</strong>
                <ul>
                    <li>New obstacles appear (green)</li>
                    <li>Search begins again</li>
                    <li>New path is found</li>
                </ul>
            </li>
        </ol>

        <h2>üéì Key Python Concepts Explained</h2>

        <h3>1. Lists vs Tuples</h3>
        <pre><code># List - can modify
my_list = [1, 2, 3]
my_list.append(4)  # OK

# Tuple - cannot modify
my_tuple = (1, 2, 3)
my_tuple.append(4)  # ERROR!</code></pre>

        <h3>2. Dictionaries</h3>
        <pre><code>came_from = {start: None}
came_from[(1, 2)] = (0, 0)  # Store value
position = came_from[(1, 2)]  # Retrieve value</code></pre>

        <h3>3. Sets</h3>
        <pre><code>explored = set()
explored.add((1, 2))  # Add item
if (1, 2) in explored:  # Check if exists
    print("Found!")</code></pre>

        <h3>4. Generators (yield)</h3>
        <pre><code>def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()
print(next(gen))  # Prints 1
print(next(gen))  # Prints 2</code></pre>

        <h2>üéÆ Controls Explained</h2>

        <h3>Keyboard Controls:</h3>
        <ul>
            <li><strong>1-4</strong>: Select different maze files</li>
            <li><strong>I</strong>: Reset to initial maze state</li>
            <li><strong>R</strong>: Reset and resize to 20x15</li>
            <li><strong>G</strong>: Change goal to random position</li>
            <li><strong>A</strong>: Add 10 random obstacles</li>
            <li><strong>D</strong>: Remove 10 random obstacles</li>
            <li><strong>Space</strong>: Restart the search</li>
            <li><strong>H</strong>: Hide/show control panel</li>
            <li><strong>P</strong>: Pause/unpause animation</li>
        </ul>

        <h3>Mouse Controls:</h3>
        <ul>
            <li><strong>Left Click</strong>: Add obstacle at clicked cell</li>
            <li><strong>Right Click</strong>: Remove obstacle at clicked cell</li>
            <li><strong>Click and Drag</strong>: Draw obstacles continuously</li>
        </ul>

        <h2>üêõ Common Questions</h2>

        <h3>Q: What is <code>self</code>?</h3>
        <p><strong>A:</strong> <code>self</code> refers to the object itself. When you call <code>maze.add_obstacle(5, 10)</code>, <code>self</code> is the <code>maze</code> object.</p>

        <h3>Q: What is <code>nonlocal</code>?</h3>
        <p><strong>A:</strong> Used in nested functions to modify variables from the outer function:</p>
        <pre><code>def outer():
    x = 5
    def inner():
        nonlocal x
        x = 10  # Modifies outer x</code></pre>

        <h3>Q: Why use <code>yield</code> instead of <code>return</code>?</h3>
        <p><strong>A:</strong> <code>yield</code> creates a generator that can be paused and resumed. Perfect for animations!</p>

        <h3>Q: What is <code>heapq</code>?</h3>
        <p><strong>A:</strong> A priority queue - always gives you the smallest item first. Perfect for A* algorithm!</p>

        <h2>üöÄ Next Steps for Learning</h2>
        <ol>
            <li><strong>Modify colors</strong> - Change the RGB values</li>
            <li><strong>Add new maze files</strong> - Create your own mazes</li>
            <li><strong>Change cell size</strong> - Make cells bigger/smaller</li>
            <li><strong>Add new controls</strong> - Implement your own features</li>
            <li><strong>Try different algorithms</strong> - BFS, DFS, Dijkstra</li>
        </ol>

        <h2>üìù Summary</h2>
        <p>This project demonstrates:</p>
        <ul>
            <li><strong>Object-Oriented Programming</strong> (Classes)</li>
            <li><strong>Algorithm Implementation</strong> (A* search)</li>
            <li><strong>Game Development</strong> (Pygame)</li>
            <li><strong>File I/O</strong> (Reading maze files)</li>
            <li><strong>Event Handling</strong> (Keyboard/Mouse)</li>
            <li><strong>Animation</strong> (Step-by-step visualization)</li>
        </ul>

        <div class="info">
            <h3>The Big Picture:</h3>
            <ol>
                <li>Load a maze from a file</li>
                <li>Use A* algorithm to find the best path</li>
                <li>Display everything with Pygame</li>
                <li>Allow user interaction</li>
                <li>Animate the solution</li>
            </ol>
        </div>

        <h2>üí° Tips for Beginners</h2>
        <ol>
            <li><strong>Start Small</strong>: Understand one function at a time</li>
            <li><strong>Print Statements</strong>: Add <code>print()</code> to see what's happening</li>
            <li><strong>Modify Values</strong>: Change numbers and see what happens</li>
            <li><strong>Read Error Messages</strong>: They tell you what's wrong!</li>
            <li><strong>Practice</strong>: Try modifying the code yourself</li>
        </ol>

        <div class="tip">
            <h3>Happy Coding! üéâ</h3>
            <p>If you have questions, try:</p>
            <ul>
                <li>Adding print statements to see values</li>
                <li>Reading Python documentation</li>
                <li>Experimenting with small changes</li>
            </ul>
        </div>
    </div>
</body>
</html>

